plugin:

  # Editing <<<

  ## Completion <<<
  prabirshrestha/async.vim: {}

  prabirshrestha/asyncomplete.vim:
    dependon: async
    after: |
      inoremap <expr> <Tab>   pumvisible() ? "\<C-n>" : "\<Tab>"
      inoremap <expr> <S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"
      inoremap <expr> <CR> pumvisible() ? asyncomplete#close_popup() . "\<CR>" : "\<CR>"
      " from the doc "
      function! s:my_asyncomplete_preprocessor(options, matches) abort
        let l:visited = {}
        let l:items = []
        for [l:source_name, l:matches] in items(a:matches)
          for l:item in l:matches['items']
            if stridx(l:item['word'], a:options['base']) == 0
              if !has_key(l:visited, l:item['word'])
                call add(l:items, l:item)
                let l:visited[l:item['word']] = 1
              endif
            endif
          endfor
        endfor
        call asyncomplete#preprocess_complete(a:options, l:items)
      endfunction

      let g:asyncomplete_preprocessor = [function('s:my_asyncomplete_preprocessor')]

  prabirshrestha/asyncomplete-buffer.vim:
    dependon: asyncomplete
    after: |
      call asyncomplete#register_source(asyncomplete#sources#buffer#get_source_options({
        \ 'name': 'buffer',
        \ 'whitelist': ['*'],
        \ 'blacklist': ['go'],
        \ 'completor': function('asyncomplete#sources#buffer#completor'),
        \ 'config': {
        \    'max_buffer_size': 5000000,
        \  },
        \ }))

  prabirshrestha/asyncomplete-file.vim:
    dependon: asyncomplete
    after: |
      call asyncomplete#register_source(asyncomplete#sources#file#get_source_options({
        \ 'name': 'file',
        \ 'whitelist': ['*'],
        \ 'priority': 10,
        \ 'completor': function('asyncomplete#sources#file#completor')
        \ }))

  yami-beta/asyncomplete-omni.vim:
    dependon: asyncomplete
    after: |
      call asyncomplete#register_source(asyncomplete#sources#omni#get_source_options({
          \ 'name': 'omni',
          \ 'whitelist': ['*'],
          \ 'completor': function('asyncomplete#sources#omni#completor'),
          \ }))

  ## >>>

  kana/vim-repeat: {}

  ## Operators <<<
  kana/vim-operator-user: {}

  rhysd/vim-operator-surround:
    dependon: operator-user
    before: |
      map <silent>sa <Plug>(operator-surround-append)
      map <silent>sd <Plug>(operator-surround-delete)
      map <silent>sr <Plug>(operator-surround-replace)
      map <silent>ss <Plug>(operator-surround-delete)a

  ## >>>

  ## Textobjs <<<
  kana/vim-textobj-user: {}

  rhysd/vim-textobj-wiw:
    dependon: textobj-user
    mapmode:
      - o
      - v
    mapping:
      - am
      - im

  thinca/vim-textobj-between:
    dependon: textobj-user
    mapmode:
      - o
      - v
    mapping:
      - <Plug>(textobj-between-a)
      - <Plug>(textobj-between-i)
    before: |
      let g:textobj_between_no_default_key_mappings = 1
      omap ib <Plug>(textobj-between-i)
      omap ab <Plug>(textobj-between-a)
      vmap ib <Plug>(textobj-between-i)
      vmap ab <Plug>(textobj-between-a)

  sgur/vim-textobj-parameter:
    dependon: textobj-user
    mapmode:
      - o
      - v
    mapping:
      - a,
      - i,

  kana/vim-textobj-underscore:
    dependon: textobj-user
    mapmode:
      - o
      - v
    mapping:
      - <Plug>(textobj-underscore-a)
      - <Plug>(textobj-underscore-i)
      - i_
      - a_
  ## >>>

  ## Utilities <<<
  tyru/caw.vim:
    dependon: repeat
    after: |
      nmap <Leader>c <Plug>(caw:hatpos:toggle)
      vmap <Leader>c <Plug>(caw:hatpos:toggle)

  cohama/lexima.vim:
    dependon: repeat
    filetype:
      - c
      - cfg
      - clojure
      - cpp
      - javascript
      - latex
      - lisp
      - plaintex
      - python
      - rust
      - scheme
      - tex
      - typescript
      - yaml
    after: |
      for specifier in [['left', 'right'], ['bigl', 'bigr'], ['Bigl', 'Bigr'], ['biggl', 'biggr'], ['Biggl', 'Biggr']]
        for bracket in [ ['(', ')'] , ['[', ']'], ]
          call lexima#add_rule({ 'char': bracket[0], 'at': '\\' . specifier[0] . '\%#', 'input_after': '\' . specifier[1] . bracket[1], 'priority' : 5, 'filetype': ['tex', 'latex'] })
        endfor
        for bracket in [ ['{', '}'] ]
          call lexima#add_rule({ 'char': bracket[0], 'at': '\\' . specifier[0] . '\\' . '\%#', 'input_after': '\' . specifier[1] . '\' . bracket[1], 'priority' : 5, 'filetype': ['tex', 'latex'] })
        endfor
      endfor

  ### Git <<<
  mhinz/vim-signify: {}

  rhysd/committia.vim:
    before: |
      let g:committia_hooks = {}
      function! g:committia_hooks.edit_open(info)
        nmap <buffer><C-b> <Plug>(committia-scroll-diff-up-page)
        nmap <buffer><C-f> <Plug>(committia-scroll-diff-down-page)
        nmap <buffer><C-y> <Plug>(committia-scroll-diff-up)
        nmap <buffer><C-e> <Plug>(committia-scroll-diff-down)

        imap <buffer><C-b> <Plug>(committia-scroll-diff-up-page)
        imap <buffer><C-f> <Plug>(committia-scroll-diff-down-page)
        imap <buffer><C-y> <Plug>(committia-scroll-diff-up)
        imap <buffer><C-e> <Plug>(committia-scroll-diff-down)
      endfunction

  ### >>>

  ## Browsing <<<

  ctrlpvim/ctrlp.vim:
    before: |
      let g:ctrlp_map = '<C-p>'
      " use mattn/files if available "
      if executable('files')
        let g:ctrlp_user_command = 'files -i="^(target|node_modules|\\.git|\\.hg|\\.svn|\\.stack-work|\\.cabal-sandbox|\\..*\.sw.)$" -a %s '
      endif
      let g:ctrlp_custom_ignore = {}
      let g:ctrlp_custom_ignore.file = '\v\.(hi|o|out|jsmod|vo|v\.d|glob|pyc)$'
      let g:ctrlp_custom_ignore.dir = '\v[\/]\.(git|hg|svn|stack-work|target)$'
    let g:ctrlp_follow_symlinks = 1
    let g:ctrlp_switch_buffer = 'Et'

  ## >>>

  kshenoy/vim-signature:
    before: |
      let g:SignatureMap = {
        \ 'GotoNextSpotByPos'  :  "]`",
        \ 'GotoPrevSpotByPos'  :  "[`",
        \ 'ListBufferMarks'    :  "m/",
        \ }

  junegunn/vim-easy-align:
    command:
      - EasyAlign
      - LiveEasyAlign

  ## >>>

  # >>>

  # Visuals <<<
  Yggdroot/indentLine:
    before: |
      let g:indentLine_first_char = "▍"
      let g:indentLine_char_list = ['▏', '┆', '┊', '┊', '┊']
      let g:indentLine_showFirstIndentLevel = 1
      let g:indentLine_faster = 1
      let g:indentLine_bufTypeExclude = ["help", "terminal"]

  luochen1990/rainbow:
    before: |
      let g:rainbow_active = 1
      let g:rainbow_conf = { 'separately': {} }
      for ft in [
          \ "css", "text", "html", "javascript", "quickrun", "lua", "help",
          \ "qf", "agit", "agit_diff", "agit_stat", "diff", "gitcommit", "coq",
          \ "clojure"
          \ ]
        let g:rainbow_conf.separately[ft] = 0
      endfor
  # >>>

  # Filetypes <<<
  lervag/vimtex:
    filetype:
      - tex
      - latex
    before: |
      " Let's see how this conflicts"
      let g:vimtex_mappings_enabled = 1

  # >>>

  # Colorschemes <<<
  nanotech/jellybeans.vim:
    before: |
      let g:jellybeans_overrides= { 'background': {'guibg': 'none' } }
      let g:jellybeans_use_term_italics = 1

  micke/vim-hybrid:
    before: |
      let g:hybrid_transparent = 1

  reedes/vim-colors-pencil: {}
  franbach/miramare:
    before: |
      let g:miramare_transparent_background = 1
  # >>>

after:
  colorscheme jellybeans

filetype:
  haskell: |
    inoremap <buffer> <C-l> <space>-> 
    setlocal colorcolumn=79 shiftround nojoinspaces
  rust: |
    inoremap <buffer> <C-l> <space>-> 
  plaintex: |
    iabbrev an &
    let g:tex_conceal=""
  tex: |
    iabbrev an &
    let g:tex_conceal=""
    setlocal backspace=indent,eol
  latex: |
    iabbrev an &
    let g:tex_conceal=""
    setlocal backspace=indent,eol
  gitcommit: |
    setlocal spell

# vim: set expandtab ts=2 sw=2 sts=2 fdm=marker fmr=<<<,>>> fdl=1:
